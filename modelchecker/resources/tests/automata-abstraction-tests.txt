/* AUTOMATA ABSTRACTION TESTS */


processes { // Defining all the processes we are going to use.
// basic abstraction
    Basic = (a -> b -> c -> STOP)\{b}.
    AbsBasic = abs(Basic).
    EqBasic = (a -> c -> STOP | a -> c -> STOP).

}

operation AbsBasic ~ EqBasic.


processes {
//abstract the first action
    Basic2 = (a -> b -> c -> STOP)\{a}.
    AbsBasic2 = abs(Basic2).
    EqBasic2 = (b -> c -> STOP).
}

operation AbsBasic2 ~ EqBasic2.

/*
processes {
//Abstract the last action
    Basic3 = (a -> b -> c -> STOP)\{c}.
    AbsBasic3 = abs(Basic3).
    EqBasic3 = (a -> (b -> STOP | b -> STOP)).
}

operation AbsBasic3 ~ EqBasic3.  // Needs cong w.r.t => []
*/
processes {
//Multiple hidden actions
    Multi = (a -> b -> c -> d -> STOP)\{b, c}.
    AbsMulti = abs(Multi).
    EqMulti = (a -> d -> STOP | a -> d -> STOP | a -> d -> STOP).
}


operation AbsMulti ~ EqMulti.

processes {
// multiple hidden actions at the beginning
    Multi2 = (a -> b -> c -> d -> STOP)\{a, b}.
    AbsMulti2 = abs(Multi2).
    EqMulti2 = (c -> d -> STOP).
}


operation AbsMulti2 ~ EqMulti2.

processes {
// multiple hidden actions at the end
    Multi3 = (a -> b -> c -> d -> STOP)\{c, d}.
    AbsMulti3 = abs(Multi3).
    EqMulti3 = (a -> (b -> STOP | b -> STOP | b -> STOP)).
}


//operation AbsMulti3 ~ EqMulti3.  // cong w.r.t. [] =>


processes {
// Action hidden to form a tau loop (assumes fair abstraction)
    Loop = (a -> A),
        A = (x -> A)\{x}.
    AbsLoop = abs(Loop).
    EqLoop = (a -> ERROR).
}


//operation AbsLoop * EqLoop.  // delta

processes {
// abstract a looped process with a hidden action
    Loop2 = (a -> x -> Loop2)\{x}.
    AbsLoop2 = abs(Loop2).
    EqLoop2 = (a -> EqLoop2 | a -> A),
        A = (a -> A|a->EqLoop2).
}


operation AbsLoop2 ~ EqLoop2.

processes {
// abstract a looped process with a hidden action
    Loop3 = (a -> b -> c -> Loop3)\{b}.
    AbsLoop3 = abs(Loop3).
    EqLoop3 = (a -> c -> EqLoop3 | a -> c -> EqLoop3).
}


operation AbsLoop3 ~ EqLoop3.

processes {
// abstracting a syncronised action in a concurrent process
    Concurrent = (a -> b -> c -> STOP || x -> b -> z -> STOP)\{b}.
    AbsConcurrent = abs(Concurrent).
    EqConcurrent = (a -> A | x -> B),
        A = (x -> C | x -> D),
        B = (a -> C | a -> D),
        C = (c -> E | z -> F),
        D = (c -> E | z -> F),
        E = (z -> STOP),
        F = (c -> STOP).
}


operation AbsConcurrent * EqConcurrent.



processes {
// abstraction example from the crib sheet
    Example = (a -> (x -> b -> STOP | c -> STOP))\{x}.
    AbsExample = abs(Example).
    EqExample = (a -> A | a -> B),
        A = (c -> STOP | b -> STOP),
        B = (b -> STOP).
}


operation AbsExample ~ EqExample.

processes {
// buffer example
    Buff = (in -> out -> Buff).
    Buff2 = (a:Buff/{x/a.out} || b:Buff/{x/b.in})\{x}.
    AbsBuff = abs(Buff2).
    EqBuff = (a.in -> A | a.in -> C),
        A = (b.out -> EqBuff | a.in -> B),
        B = (b.out -> A | b.out -> C),
        C = (a.in -> B | b.out -> EqBuff).
}


operation AbsBuff ~ EqBuff.





