/* AUTOMATA ABSTRACTION TESTS */


processes { // Defining all the processes we are going to use.
// basic abstraction
    Basic = (a -> b -> c -> STOP)\{b}.
    AbsBasic = abs(Basic).
    EqBasic = (a -> c -> Stop | a -> c -> Stop),
        Stop = (STOP).

}

automata AbsBasic,EqBasic,Basic. //Set the constructs to be created as Automata
operation AbsBasic ~ EqBasic. // Do the operation


processes {
//abstract the first action
    Basic2 = (a -> b -> c -> STOP)\{a}.
    AbsBasic2 = abs(Basic2).
    EqBasic2 = (b -> c -> STOP).
}

automata Basic2,AbsBasic2,EqBasic2.
operation AbsBasic2 ~ EqBasic2.


processes {
//Abstract the last action
    Basic3 = (a -> b -> c -> STOP)\{c}.
    AbsBasic3 = abs(Basic3).
    EqBasic3 = (a -> (b -> STOP | b -> STOP)).
}

automata Basic3,AbsBasic3,EqBasic3.
operation AbsBasic3 ~ EqBasic3.

processes {
//Multiple hidden actions
    Multi = (a -> b -> c -> d -> STOP)\{b, c}.
    AbsMulti = abs(Multi).
    EqMulti = (a -> d -> Stop | a -> d -> Stop | a -> d -> Stop),
        Stop = (STOP).
}

automata Multi,AbsMulti,EqMulti.
operation AbsMulti ~ EqMulti.

processes {
// multiple hidden actions at the beginning
    Multi2 = (a -> b -> c -> d -> STOP)\{a, b}.
    AbsMulti2 = abs(Multi2).
    EqMulti2 = (c -> d -> STOP).
}

automata Multi2,AbsMulti2,EqMulti2.
operation AbsMulti2 ~ EqMulti2.

processes {
// multiple hidden actions at the end
    Multi3 = (a -> b -> c -> d -> STOP)\{c, d}.
    AbsMulti3 = abs(Multi3).
    EqMulti3 = (a -> (b -> STOP | b -> STOP | b -> STOP)).
}

automata Multi3,AbsMulti3,EqMulti3.
operation AbsMulti3 ~ EqMulti3.

processes {
// Action hidden to form a tau loop (assumes fair abstraction)
    Loop = (a -> A),
        A = (x -> A)\{x}.
    AbsLoop = abs(Loop).
    EqLoop = (a -> ERROR).
}

automata Loop,AbsLoop,EqLoop.
operation AbsLoop ~ EqLoop.

processes {
// abstract a looped process with a hidden action
    Loop2 = (a -> x -> Loop2)\{x}.
    AbsLoop2 = abs(Loop2).
    EqLoop2 = (a -> EqLoop2 | a -> A),
        A = (a -> A|a->EqLoop2).
}

automata Loop2,AbsLoop2,EqLoop2.
operation AbsLoop2 ~ EqLoop2.

processes {
// abstract a looped process with a hidden action
    Loop3 = (a -> b -> c -> Loop3)\{b}.
    AbsLoop3 = abs(Loop3).
    EqLoop3 = (a -> c -> EqLoop3 | a -> c -> EqLoop3).
}

automata Loop3,AbsLoop3,EqLoop3.
operation AbsLoop3 ~ EqLoop3.

processes {
// abstracting a syncronised action in a concurrent process
    Concurrent = (a -> b -> c -> STOP || x -> b -> z -> STOP)\{b}.
    AbsConcurrent = abs(Concurrent).
    EqConcurrent = (a -> A | x -> B),
        A = (x -> C | x -> D),
        B = (a -> C | a -> D),
        C = (c -> E | z -> F),
        D = (c -> E | z -> F),
        E = (z -> Stop),
        F = (c -> Stop),
        Stop = (STOP).
}

automata Concurrent,AbsConcurrent,EqConcurrent.
operation AbsConcurrent ~ EqConcurrent.

processes {
// abstracting a single action in a concurrent process
Concurrent2 = (a -> b -> c -> STOP || x -> y -> z -> STOP)\{b}.
    AbsConcurrent2 = abs(Concurrent2).
    EqConcurrent2 = (a -> A | a -> B | x -> D),
        A = (c -> C | x -> E | x -> F),
        B = (c -> C | x -> F),
        C = (x -> G),
        D = (a -> E | a -> F | y -> H),
        E = (c -> G | y -> I | y -> J),
        F = (c -> G | y -> J),
        G = (y -> K),
        H = (a -> I | a -> J | z -> L),
        I = (c -> K | z -> M | z -> N),
        J = (c -> K | z -> N),
        K = (z -> Stop),
        L = (a -> M | a -> N),
        M = (c -> Stop),
        N = (c -> Stop),
        Stop = (STOP).
}

automata Concurrent2,AbsConcurrent2,EqConcurrent2.
operation AbsConcurrent2 ~ EqConcurrent2.

processes {
// abstraction example from the crib sheet
    Example = (a -> (x -> b -> STOP | c -> STOP))\{x}.
    AbsExample = abs(Example).
    EqExample = (a -> A | a -> B),
        A = (c -> STOP | b -> Stop),
        B = (b -> Stop),
        Stop = (STOP).
}

automata Example, AbsExample,EqExample.
operation AbsExample ~ EqExample.

processes {
// buffer example
    Buff = (in -> out -> Buff).
    Buff2 = (a:Buff/{x/a.out} || b:Buff/{x/b.in})\{x}.
    AbsBuff = abs(Buff2).
    EqBuff = (a.in -> A | a.in -> C),
        A = (b.out -> EqBuff | a.in -> B),
        B = (b.out -> A | b.out -> C),
        C = (a.in -> B | b.out -> EqBuff).
}

automata Buff,Buff2,AbsBuff,EqBuff.
operation AbsBuff ~ EqBuff.


