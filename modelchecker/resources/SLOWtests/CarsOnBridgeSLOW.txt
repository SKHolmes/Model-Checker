/*     Reworking Abrials Cars on a bridge in process algebra
Establishes liveness properties for a finite state approximation.
*/
const Max = 2.
const Cnum = 3.
processes {
/* 
   model that clearly satisfies the  Max number of cars
   Assumes System sees how many cars are one the island
*/
M1 =  C[0],
  C[i:0..Max] = (when (i < Max) ml2is -> C[i+1]
                | when (i > 0) is2ml -> C[i-1]).

/*
   New model that satisfies one way bridge
   Assumes System sees: 1. how many cars are one the island
            2. when a car is on the bridge
*/
M2 = C[0][0][0],
 C[mlis:0..Max][is:0..Max][isml:0..Max] =
  (when((isml == 0) && ((mlis + is) < Max))    ml2br->C[mlis+1][is][isml]
  |when((mlis>0)  && (is<Max))                 br2is->C[mlis-1][is+1][isml]
  |when((mlis == 0) && (is > 0) && (isml<Max)) is2br->C[mlis][is-1][isml+1]
  | when (isml>0)                              br2ml->C[mlis][is][isml-1]).


// note because a global perspective is taken complete trace semantics is used
 M2to1 = simp (nfa2dfa(abs (M2/{ml2is/ml2br,is2ml/br2ml}\{br2is,is2br}))). 

// used to show the need for complete trace semantics not failure semantics 
 M2bis1 = simp (abs (M2/{ml2is/ml2br,is2ml/br2ml}\{br2is,is2br})). 
}
automata M1,M2to1,M2bis1.
operation{
M1 ~ M2to1.    // M2 is a complete trace refinement of M1
M1 !~ M2bis1. // NOT a failure refinement
}

processes {
/*
  Introduce trafic lights so car only moves when trafic light is green.
      Similar assumptions as M2
*/
TLred = (red->TLred | turnGreen->TLgreen),
   TLgreen = (green-> TLgreen | turnRed -> TLred).
TLgreen = (green-> TLgreen | turnRed -> TLred),
    TLred = (red->TLred | turnGreen->TLgreen).

M3 = (ml:TLgreen / {ml2br/ml.green} || 
          is:TLred   /{is2br/is.green}  ||
            M2 ) \{is.turnRed,is.turnGreen,is.red,
                       ml.turnRed,ml.turnGreen,ml.red}.

M3to1 = simp(nfa2dfa(abs(M3/{ml2is/ml2br,is2ml/br2ml}\{br2is,is2br}))).

M3to2 = simp(nfa2dfa(abs(M3))).
}
automata M3to1,M3to2.
operation{
M1 ~ M3to1.   // sanity check - debugging step
M2 ~ M3to2.  //M3 is a complete trace refinement of M2
}

processes {
/* only one car at a time can cross one sensor 
   the seeOn event allows the controller to test the sensor
   alternativly an additional state could be added to the controller
*/
//Sensor = ([j:1..Cnum].seeOff -> Sensor |([j].on -> [j].off->Sensor)).
Sensor = ([j:1..Cnum].on -> [j].off->Sensor).
        

/*
many cars can see the green light  but cars do not all need to see it
red only needed to control turning the island traffic light green.
*/

TL = ( [j:1..Cnum].red->TL |turnGreen->TLgx),  //  [j:1..Cnum].red->TL |
   TLgx = ([j:1..Cnum].green-> TLgx | turnRed -> TL). 
TLg = ([j:1..Cnum].green-> TLg | turnRed -> TLx),    
  TLx = ( [j:1..Cnum].red->TLx |turnGreen->TLg).    // [j:1..Cnum].red->TLx |
  
/* To force the car to move quickly of the sensor when it sees the light is green
   we rename the  "off" events.
*/
TLml = ml:TLg /{ml2br.[i:1..Cnum].off/ml.[i:1..Cnum].green}.
TLis = istl:TL /{is2br.[i:1..Cnum].off/istl.[i:1..Cnum].green}.


/*
The sensors are input to the controller that
    1.  always responds to sensor information
    2.  only switches the lights when safe to do so
Drivers move as soon as they see a green light!  If the driver waits, 
    and allows the lights to change color, then moves off with out checking the light
    they will crash.
    a) Tl(green) sync with Car(green)  
    b) rename green to sen.off  so that the Car moves promptly 
    Error 1.  Cars not obeying one way bridge  will crash
    Error 2.  Overfill the bridge+island report failMax
    
 The use of ranges 0..Max+1 means the controller will allow the system to fail 
 if the cars do not obey the trafic lights!
 
 */
 Controller = C[0][0][0][0][0],
C[mlis:0..Max+1][is:0..Max+1][isml:0..Max+1][mls:0..1][iss:0..1] =
 ( when (mlis +isml+ is == Max) ml.turnRed->C[mlis][is][isml][mls][iss]
| when((mlis ==0) && (iss == 1))  ml.turnRed->istl.turnGreen->C[mlis][is][isml][mls][iss]
| when((mlis ==0) && (iss == 1))  ml.[i:1..Cnum].red->istl.turnGreen->C[mlis][is][isml][mls][iss]

| when(isml==0 && (is + isml<Max) && mls==1) istl.turnRed->
                                            ml.turnGreen->C[mlis][is][isml][mls][iss]
 | when (mlis > 0 && isml> 0)       crash -> STOP
 | when (mlis < 0 || isml< 0)       imposible -> STOP
 | when (mlis +isml+ is > Max) failMax->STOP
 
|  when (mls == 0 && !((mlis ==0) && (is > 0) && iss == 0)) 
                             ml2br.[j:1..Cnum].on -> C[mlis][is][isml][1][iss]
// the car only askes to go  off after seeing green and the controller turne the light
| when (mls==1 &&(mlis +isml+ is < (Max-1))) ml2br.[j:1..Cnum].off->
                                     C[mlis+1][is][isml][0][iss]
| when (mls==1 &&(mlis +isml+ is == (Max-1))) ml2br.[j:1..Cnum].off->ml.turnRed->
                                     C[mlis+1][is][isml][0][iss]

// only one cart can be on the sensor at a time 

| when (mlis> 0 && is<=Max)  
       br2is.[j:1..Cnum].off->C[mlis-1][is+1][isml][mls][iss]                 
| when (iss == 0) is2br.[j:1..Cnum].on -> C[mlis][is][isml][mls][1]
| when (iss == 1 &&(is>0 && isml <= Max))   
                    is2br.[j:1..Cnum].off->C[mlis][is-1][isml+1][mls][0]
| when (isml > 0)   br2ml.[j:1..Cnum].off->C[mlis][is][isml-1][mls][iss]

).

 // | when (mlis == Max)    [j:1..Cnum].ml2br ->failMLis->STOP
// | when (isml == Max)    [j:1..Cnum].is2br ->failISml->STOP

 /*  
 a Car controlls when the sensors is off and on 
 but waether a  Car moves off a sensor is controlled by the trafic lights
 */
 Car =   Loc[0],
   Loc[loc:0..3] =
       ( when (loc ==0)   ml2br.on -> ml.green-> ml2br.off ->  Loc[1]
       | when (loc  == 1) br2is.on -> br2is.off ->  Loc[2]
       | when (loc == 2)  is2br.on -> istl.green-> is2br.off -> Loc[3]
       | when (loc == 3)  br2ml.on -> br2ml.off-> Car
       ).

Cars = (forall [i:1..Cnum]  ([i]:Car))/{ml2br.[i:1..Cnum].on/[i].ml2br.on,    
                                        is2br.[i:1..Cnum].on/[i].is2br.on,
        ml2br.[i:1..Cnum].off/[i].ml2br.off,  is2br.[i:1..Cnum].off/[i].is2br.off,
        br2ml.[i:1..Cnum].off/[i].br2ml.off,  br2is.[i:1..Cnum].off/[i].br2is.off,
        br2ml.[i:1..Cnum].on/[i].br2ml.on,    br2is.[i:1..Cnum].on/[i].br2is.on,
        ml.[i:1..Cnum].green/[i].ml.green, istl.[i:1..Cnum].green/[i].istl.green}.


M4 = (Controller ||  ml2br:Sensor||br2is:Sensor|| br2ml:Sensor||is2br:Sensor||
         TLml || 
         TLis ||  Cars ).  // ml[i:1..Cnum].red/[i].ml.red,

M4to2 = simp(nfa2dfa(abs(M4/{is2br/[i:1..Cnum].is2br, 
                           ml2br/ml2br.[i:1..Cnum].off,
                           br2ml/br2ml.[i:1..Cnum].off,
                           br2is/br2is.[i:1..Cnum].off,
                           is2br/is2br.[i:1..Cnum].off
           } \{ml2br.[i:1..Cnum].on,
              is2br.[i:1..Cnum].on,
              br2is.[i:1..Cnum].on,
              br2ml.[i:1..Cnum].on,
              ml.[i:1..Cnum].green,ml.[i:1..Cnum].red,   ml.turnRed,ml.turnGreen,
             istl.[i:1..Cnum].green,  istl.[i:1..Cnum].red,
             istl.turnRed,istl.turnGreen
                
           }))).
   
M4to1 = simp(nfa2dfa(abs(M4to2/{ml2is/ml2br,is2ml/br2ml}\{br2is,is2br}))).


}
//automata Car, Controller.
automata M4to1,M4to1
operation{
M1 ~ M4to1.  // sanity - debugging
M2 ~ M4to2.  // M4 is a complete trace refinement of M2
} 


lengthEdgeValue: 10
maxNodeLabelValue: 10
operationFailureLabelValue: 10
operationPassLabelValue: 10

fairAbstractionSelected: false
autoSaveSelected: false
darkModeSelected: false
pruningSelected: false
liveCompillingSelected: false
